key1     Ruten's first process key press

    while (read(STDIN_FILENO, &c, 1) == 1 && c != 'q')

rkey     Ruten read key, time out strategy for handling
         escape 

         convert single characters and escape sequences 
         into a code
 
  if (c == '\x1b') {
    char seq[3];
    if (read(STDIN_FILENO, &seq[0], 1) != 1) return '\x1b';
    if (read(STDIN_FILENO, &seq[1], 1) != 1) return '\x1b';

rkey     Ruten read key, decode escape sequence

    if (seq[0] == '[') {
    if (seq[1] >= '0' && seq[1] <= '9') {
        if (read(STDIN_FILENO, &seq[2], 1) != 1) return '\x1b';
        if (seq[2] == '~')
        switch (seq[1])
            case '1': return HOME_KEY;
            case '3': return DEL_KEY;
            case '4': return END_KEY;
            case '5': return PAGE_UP;
            case '6': return PAGE_DOWN;
            case '7': return HOME_KEY;
            case '8': return END_KEY;
      
    else switch (seq[1]) 
           case 'A': return ARROW_UP;
           case 'B': return ARROW_DOWN;
           case 'C': return ARROW_RIGHT;
           case 'D': return ARROW_LEFT;
           case 'H': return HOME_KEY;
           case 'F': return END_KEY;
   
    else if (seq[0] == 'O') switch (seq[1]) 
           case 'H': return HOME_KEY;
           case 'F': return END_KEY;
   
    return '\x1b';

    else return c;

pkeyp    Ruten's final process key press: switch / case

  int c = editorReadKey();
  switch (c) {
    case CTRL_KEY('q'):
      break;
    case HOME_KEY:
      break;
    case END_KEY:
      break;
    case PAGE_UP:
    case PAGE_DOWN:
      break;
    case ARROW_UP:
    case ARROW_DOWN:
    case ARROW_LEFT:
    case ARROW_RIGHT:
      editorMoveCursor(c);
      break;
    default:
      editorInsertChar(c);
      break;

basc     build a screen

    printf("wrapb processing <%s>\n",s);
    char mocu[32];
    snprintf(mocu,32,"\x1b[%d;%df",i,j); 
     
    int len; len = (int) strlen(mocu);
    abAppend(ab, mocu, len); 
                
    len = (int) strlen(s);
    abAppend(ab, s, len);   

VT100    display control escape sequences

    char ClearScreen[]=                         "\x1b[2J";
    char CursorToTopLeft[] =                    "\x1b[H";
    char TildeReturnNewline[] =                 "~\r\n";
    char ReturnNewline[] =                      "\r\n";

    char CursorToMaxForwardMaxDown[]=           "\x1b[999C\x1b[999B";
    char GetCursorPosition[] =                  "\x1b[6n";

    char CursorHide[]=                          "\x1b[?25l";
    char CursorDisplay[]=                       "\x1b[?25h";
    char ClearCurrentLine[]=                    "\x1b[K";
    char CursorToCenter[]=                      "\x1b[12;30f";

adal     add a line to the text buffer
107      add a line to the text buffer

    int newlen = maxndx + 1 + 1;
    slot *new  = (slot *)malloc(newlen*sizeof(slot));

    slot newline;
    newline.row = qtr;

    slot *old = text; 

    int i,j,k; i = 0; j = 0; k = 0;
    for (i = 0 ; i < maxndx + 1 ; i++) 
      {if (i != here) {new[j] = old[k]; j++; k++;}
       else           {new[j] = old[k]; j++; k++;
                       new[j] = newline;     j++;}
      }


107      delete a line from the text buffer

    slot *new  = (slot *)malloc(newlen*sizeof(slot));

    slot *old = text; 

    int i,j,k; i = 0; j = 0; k = 0;
    for (i = 0 ; i < maxndx + 1 ; i++) 
      {if (i != omit) {new[j] = old[k]; j++; k++;}
       else           {                      k++;}
      }


